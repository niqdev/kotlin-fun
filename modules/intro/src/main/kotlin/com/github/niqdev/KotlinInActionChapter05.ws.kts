// Lambda expressions, or simply lambdas, are essentially small chunks of code that can be passed to other functions

data class Person(val name: String, val age: Int)
val people = listOf(Person("Alice", 29), Person("Bob", 31))
// lambda expressions
// The code in curly braces { it.second } is a lambda implementing that logic. It receives a collection element as an argument (referred to using it) and returns a value to compare
// null ???
// `it` is an autogenerated parameter name
people.maxByOrNull { it.age }
// syntactic convention lets you move a lambda expression out of parentheses if it's the last argument in a function call
people.maxByOrNull() { p: Person -> p.age }
// when the lambda is the only argument to a function, you can also remove the empty parentheses from the call
// parameter type explicitly written
people.maxByOrNull { p: Person -> p.age }
// parameter type inferred
people.maxByOrNull { p -> p.age }
// If you store a lambda in a variable, there's no context from which to infer the parameter types, so you have to specify them explicitly
val getAge = { p: Person -> p.age }
people.maxByOrNull(getAge)
// member references
people.maxByOrNull(Person::age)

// ------------------------------

// A lambda expression in Kotlin is always surrounded by curly braces
// Note that there are no parentheses around the arguments.
// The arrow separates the argument list from the body of the lambda

val sum = { x: Int, y: Int -> x + y }
println(sum(1, 2))

// call the lambda expression directly
val lambda: Unit = { println(42) }()

// if you need to enclose a piece of code in a block, you can use the library function run that executes the lambda passed to it
run { println(42) }

// ------------------------------

// >>> !!! Kotlin, unlike Java, allows you to access non-final variables and even modify them in a lambda !!!
// External variables accessed from a lambda are said to be "captured" by the lambda
// the lifetime of a local variable is constrained by the function in which the variable is declared
// But if it's captured by the lambda, the code that uses this variable can be stored and executed later
// When you capture a final variable, its value is stored together with the lambda code that uses it
// For non-final variables, the value is enclosed in a special wrapper that lets you change it, and the reference to the wrapper is stored together with the lambda

// TODO pag 110
