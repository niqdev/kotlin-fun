val mySet = hashSetOf(1, 8, 42)
val myArray = arrayListOf(1, 8, 42)
// `to` is a function
val myMap = hashMapOf(1 to "one", 8 to "eight", 42 to "forty-two")

// Kotlin uses the standard Java collection classes
// Kotlin doesn't have its own set of collection classes
println(mySet.javaClass)
println(myArray.javaClass)
println(myMap.javaClass)

val myStrings = listOf("one", "eight", "forty-two")
val myInts = setOf(1, 8, 42)

// throws exceptions ;-(
println(myStrings.last())
// null ;-(
println(myInts.maxOrNull())

// ------------------------------

// Given that Java doesn't have the concept of default parameter values,
// you have to specify all the parameter values explicitly when you call a Kotlin function with default parameter values from Java
// `@JvmOverloads` instructs the compiler to generate Java overloaded methods, omitting each of the parameters one by one, starting from the last one

// ------------------------------

// Java, as an object-oriented language, requires all code to be written as methods of classes
// In Kotlin, you don't need to create all those meaningless classes.
// Instead, you can place functions directly at the top level of a source file, outside of any class
// when you compile the file, some classes will be produced, because the JVM can only execute code in classes
// the name of the class generated by the Kotlin compiler corresponds to the name of the file containing the function.
// All top-level functions in the file are compiled to static methods of that class
// calling this function from Java is as easy as calling any other static method

// to change the name of the generated class that contains Kotlin top-level functions,
// you add a `@JvmName` annotation to the file. Place it at the beginning of the file, before the package name
/*
>>> file name: `join.kt`

// import from Java
import strings.JoinKt;
JoinKt.joinToString(...)

// rename file
@file:JvmName("StringFunctions")
package strings
fun joinToString(...): String {...}

// import from Java
import strings.StringFunctions;
StringFunctions.joinToString(...)
*/

// ------------------------------

// to expose a constant to Java code as a `public static final` field
object example {
  const val UNIX_LINE_SEPARATOR = "\n"
}

// ------------------------------

// extension functions and properties: Pimp My Library pattern
// https://www.artima.com/weblogs/viewpost.jsp?thread=179766

// it's a function that can be called as a member of a class but is defined outside of it
// put the name of the class or interface that you're extending before the name of the function you're adding
// This class name is called the `receiver type`; the value on which you're calling the extension function is called the `receiver object`
// e.g. `List` is the `receiver type` and `this` is the `receiver object`
fun <T> List<T>.lastOptional(): java.util.Optional<T> =
  this.lastOrNull()?.let { java.util.Optional.of(it) } ?: java.util.Optional.empty()

listOf(1, 2, 3).lastOptional()
listOf<Int>().lastOptional()

// - extension functions don't have access to private or protected members of the class
// - extension functions need to be imported
// e.g. import alias: `import strings.lastChar as last`
// - you can't override an extension function

// ------------------------------

// `*` is called `spread operator` to explicitly unpack the array
fun <T> myVarArg(vararg values: T): List<T> = listOf(*values)

// ------------------------------

// infix calls and destructuring declarations
// In an infix call, the method name is placed immediately between the target object name and the parameter, with no extra separators

// Calls the `to` function the regular way
1.to("one")
// Calls the `to` function using an infix notation
1 to "one"

// PAIR
infix fun Any.myTo(other: Any) = Pair(this, other)
// destructuring declaration
//val (aNumber, aNumber) = 1 myTo "one"
//println("$aNumber: $aNumber")

// ------------------------------

// the regular expression is written in a triple-quoted string
// In such a string, you don't need to escape any characters, including the backslash
val myregex = """(.+)/(.+)\.(.+)""".toRegex()

val kotlinLogo = """| //
                   .|//
                   .|/ \"""
println(kotlinLogo.trimMargin("."))
